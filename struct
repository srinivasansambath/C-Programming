

#include <stdio.h>

int main()
{
    struct emp 
    {
        int eid;
        char ename [20];
        float esal;
    };
    printf("%d %s %f",sizeof(e1.eid),sizeof(e1.ename),sizeof(e1.esal));
    return 0;
}
// OUTPUT:
/*Compilation error.
In this program compiilation error occurs beacuse only planning is done in struct block and no memory is created.
So when we are trying to check the size of operators we will get error.*/

// Program for struct
#include <stdio.h>

int main()
{
    struct emp 
    {
        int eid;
        char ename [20];
        float esal;
    };
    struct emp e1 ={1,"srini",1000000};
    printf("%d %s %f",e1.eid,e1.ename,e1.esal);
    

    return 0;
}
OUTPUT:
1 srini 1000000.000000

// program for struct
main()
{
    struct  emp 
    {
        int eid=10;
        char ename[20]="Dell";
        float esal=100000;
    };
    struct emp e1;
    printf("%d,%s,%f",e1.eid,e1.ename,e1.esal);
}

Output:
Compilation error occurs because values can't be initialized in struct where memory not created.

//Struct program related to garbage string
#include<stdio.h>
main()
{
    struct  emp 
    {
        int eid;
        char ename[20];
        float esal;
    };
    struct emp e1;
    e1.eid=10;
    e1.ename[20]="Dell";
    e1.esal=100000;

    printf("%d %s %f",e1.eid,e1.ename,e1.esal);
}
OUTPUT:
// Sometimes prints 10 GV 100000.0000000
sometimes compilation error occurs because of compilers.
// Reason : String can't be assigned into an char array directly.

#include<stdio.h>
main()
{
    struct  emp 
    {
        int eid;
        char ename[20];
        float esal;
    };
    struct emp e1;
    e1.eid=10;
    strcpy(e1.ename,"dell");
    e1.esal=100000;

    printf("%d %s %f",e1.eid,e1.ename,e1.esal);
}
OUTPUT:
10 dell 100000.000000



